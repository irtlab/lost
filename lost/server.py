from __future__ import annotations
import sys
import os
import click
import atexit
import psycopg
import lxml.objectify
import lxml.etree
from psycopg_pool import ConnectionPool
from psycopg.adapt import Loader, Dumper
from datetime import datetime, timedelta
from lxml.etree import Element, SubElement, XML
from abc import ABC, abstractmethod
from flask import Flask, request, Response, current_app
from flask_cors import CORS
from .guid import GUID
from . import GML_NAMESPACE, LOST_NAMESPACE, XML_NAMESPACE, NAMESPACE_MAP, MIME_TYPE, SRS_URN
from .errors import (LoSTError, BadRequest, NotFound, LocationProfileUnrecognized,
    NotImplemented, GeometryNotImplemented, SRSInvalid)
from .geometry import Point


# Create a pool of persistent PostgreSQL database connections. When we are done
# with a PostgreSQL connection, we simply return it to the pool without closing
# the connection. This helps avoid the need to open a new database connection
# for every request.
pool: ConnectionPool


# Instances of LoST servers for various coodinate systems, e.g., geodetic-2d and
# civic.
lost_server: dict[str, LoSTServer] = dict()


def adapt_for_guid(con: psycopg.Connection):
    class GUIDLoader(Loader):
        def load(self, data):
            return GUID(str(data, 'ascii'))


    class GUIDDumper(Dumper):
        oid = psycopg.adapters.types["uuid"].oid

        def dump(self, data):
            return f"{data.value}".encode('ascii')

    con.adapters.register_loader('uuid', GUIDLoader)
    con.adapters.register_dumper(GUID, GUIDDumper)


class LoSTServer(ABC):
    '''An abstract LoST server base class

    This class is not meant to be instantiated directly. It just provides an
    interface that all address-type-specific LoST server implementations must
    provide.

    Instantiate GeographicLoSTServer or CivicLostServer instead.
    '''
    def __init__(self, server_id, table):
        self.server_id = server_id
        self.table = table

    @abstractmethod
    def findService(self, req: lxml.objectify.ObjectifiedElement):
        raise NotImplemented('<findService> not implemented')


def serviceBoundary(value: str, gml_ns=GML_NAMESPACE, profile="geodetic-2d"):
    '''Convert ST_AsGML output to a service boundary object

    This function constructs a serviceBoundary XML element tree from the output
    generated by PostGIS' ST_AsGML function. ST_AsGML should be configured to
    generate GML version 3 using the standard namespace prefix "gml", for
    example: ST_AsGML(3, shape, 5, 17)

    Since ST_AsGML does not declare the gml namespace, we need to create a new
    root element here and declare the namespace there. Otherwise, lxml would not
    be able to parse the output of ST_AsGML.
    '''

    parser = lxml.etree.XMLParser(remove_blank_text=True)
    return XML(f'''
        <serviceBoundary profile="{profile}" xmlns:gml="{gml_ns}">
            {value}
        </serviceBoundary>''', parser)


class GeographicLoSTServer(LoSTServer):
    def findPoint(self, service, point: Point):
        with pool.connection() as con:
            cur = con.execute('''
                SELECT m.id, m.service, m.modified, m.attrs, ST_AsGML(3, s.geometries, 5, 17)
                FROM   mapping AS m JOIN shape AS s ON m.shape=s.id
                WHERE  ST_Contains(s.geometries, ST_GeomFromText(%s, 4326))
                    and m.service = %s''',
                (f'Point({point.lon} {point.lat})', service))

            row = cur.fetchone()

        if row is None:
            raise NotFound('No suitable mapping found')

        id, service, modified, attrs, shape = row

        res = Element(f'{{{LOST_NAMESPACE}}}findServiceResponse', nsmap=NAMESPACE_MAP)
        mapping = SubElement(res, 'mapping',
            source=self.server_id,
            sourceId=str(id),
            lastUpdated=modified.isoformat(),
            expires=(datetime.now() + timedelta(days=1)).isoformat())

        if 'displayName' in attrs:
            dn = SubElement(mapping, 'displayName')
            dn.set(f'{{{XML_NAMESPACE}}}lang', 'en')
            dn.text = attrs['displayName']

        SubElement(mapping, 'service').text = service
        mapping.append(serviceBoundary(shape))

        for uri in attrs.get('uri', []):
            SubElement(mapping, 'uri').text = uri

        return res

    def findPolygon(self, service, polygon):
        polygon = lxml.etree.tostring(polygon, pretty_print=True).decode()

        with pool.connection() as con:
            cur = con.execute('''
                    SELECT m.id, m.service, m.modified, m.attrs, ST_AsGML(s.geometries, 3) AS gml
                    FROM   mapping AS m JOIN shape AS s ON m.shape=s.id
                    WHERE  ST_Intersects(s.geometries, ST_GeomFromGML(%s, 4326))
                        and m.service = %s''',
                    (polygon, service))
    
            
            row = cur.fetchone()
        
        if row is None:
            raise NotFound('No suitable mapping found')

        id, service, modified, attrs, shape = row

        res = Element(f'{{{LOST_NAMESPACE}}}findServiceResponse', nsmap=NAMESPACE_MAP)
        mapping = SubElement(res, 'mapping',
            source=self.server_id,
            sourceId=str(id),
            lastUpdated=modified.isoformat(),
            expires=(datetime.now() + timedelta(days=1)).isoformat())

        if 'displayName' in attrs:
            dn = SubElement(mapping, 'displayName')
            dn.set(f'{{{XML_NAMESPACE}}}lang', 'en')
            dn.text = attrs['displayName']

        SubElement(mapping, 'service').text = service
        mapping.append(serviceBoundary(shape))

        for uri in attrs.get('uri', []):
            SubElement(mapping, 'uri').text = uri

        return res

    def findService(self, req: lxml.objectify.ObjectifiedElement):
        service = req.service.text
        if service is not None:
            service = service.strip()

        geom = req.location.getchildren()[0]

        if geom.attrib.get('srsName') != SRS_URN:
            raise SRSInvalid('Unsupported SRS name')

        if geom.tag == f'{{{GML_NAMESPACE}}}Point':
            lat, lon = (geom.pos.text or '').strip().split()
            return self.findPoint(service, Point(lon, lat))
        
        elif geom.tag == f'{{{GML_NAMESPACE}}}Polygon':
            return self.findPolygon(service, geom)
        
        else:
            raise GeometryNotImplemented(f'Unsupported geometry type {geom.tag}')


class CivicLoSTServer(LoSTServer):
    def findService(self, doc):
        pass


app = Flask(__name__)
CORS(app)


def xmlify(doc) -> Response:
    lxml.objectify.deannotate(doc, cleanup_namespaces=True, xsi_nil=True)
    return Response(lxml.etree.tostring(doc, encoding='UTF-8',
        pretty_print=True, xml_declaration=True), mimetype=MIME_TYPE)


def findService(req):
    profile = req.location.attrib['profile']
    try:
        server = lost_server[profile]
        return server.findService(req)
    except KeyError as e:
        raise LocationProfileUnrecognized(f"Unsupported location profile '{profile}'") from e


def getServiceBoundary(req):
    raise NotImplemented('<getServiceBoundary> not implemented')


def listServices(req):
    raise BadRequest('<listServices> not implemented')


def listServicesByLocation(req):
    raise BadRequest('<listServicesByLocation> not implemented')


@app.route("/", methods=["GET"])
def ping():
    with pool.connection() as con:
        res = con.execute("SELECT NOW()").fetchone()
        assert res is not None
        return f"Database says: {res[0]}"


@app.route("/", methods=["POST"])
def lost_request():
    if request.mimetype != MIME_TYPE:
        raise BadRequest('Unknown Content-Type')

    try:
        req = lxml.objectify.fromstring(request.data)
    except lxml.etree.XMLSyntaxError as e:
        raise BadRequest(f'XML syntax error: {e}') from e

    if not req.tag.startswith(f'{{{LOST_NAMESPACE}}}'):
        raise BadRequest('Unsupported XML namespace')

    type_ = req.tag[len(LOST_NAMESPACE) + 2:]
    if   type_ == 'findService':            res = findService(req)
    elif type_ == 'getServiceBoundary':     res = getServiceBoundary(req)
    elif type_ == 'listServices':           res = listServices(req)
    elif type_ == 'listServicesByLocation': res = listServicesByLocation(req)
    else: raise NotImplemented(f'Unsupported request type "{type_}"')

    return xmlify(res)


@app.errorhandler(LoSTError)
def lost_error(exc: LoSTError):
    return xmlify(exc.to_xml(current_app.config.get('server-id', None)))


@click.group(invoke_without_command=True)
@click.pass_context
def cli(ctx):
    try:
        if ctx.invoked_subcommand is None:
            ctx.invoke(start)
    except KeyboardInterrupt:
        pass
    pass


@cli.command()
@click.option('--port', '-p', type=int, help='Port number to listen on.')
@click.option('--db-url', '-d', help='PostgreSQL database URL')
@click.option('--max-con', default=16, help='Maximum number of DB connections', show_default=True)
@click.option('--min-con', default=1, help='Minimum number of free DB connections', show_default=True)
@click.option('--geo-table', default='geo', help='Name of geographic mapping table', show_default=True)
@click.option('--civic-table', default='civic', help='Name of civic address mapping table', show_default=True)
@click.option('--server-id', default='lost-server', help='Unique ID of the LoST server', show_default=True)
def start(port, db_url, max_con, min_con, geo_table, civic_table, server_id):
    global pool, lost_server

    if db_url is None:
        try:
            db_url = os.environ['DB_URL']
        except KeyError:
            print("Error: Please configure database via --db-url or environment variable DB_URL")
            sys.exit(1)

    try:
        pool = ConnectionPool(db_url, min_size=min_con, max_size=max_con, num_workers=1, kwargs={
            'autocommit': True
        }, configure=adapt_for_guid)
        atexit.register(lambda: pool.close())
        # Wait for the connection pool to create its first connections. We want
        # to fail early if the database cannot be connected for some reason.
        pool.wait()
    except Exception as e:
        print(f"Error while connecting to datababase '{db_url}': {e}")
        sys.exit(1)

    if port is None:
        port = int(os.environ.get("PORT", 5000))

    if geo_table != None:
        print("Instantiating a LoST server for the 'geodetic-2d' profile")
        lost_server['geodetic-2d'] = GeographicLoSTServer(server_id, geo_table)

    if civic_table != None:
        print("Instantiating a LoST server for the 'civic' profile")
        lost_server['civic'] = CivicLoSTServer(server_id, civic_table)

    app.config['server-id'] = server_id
    app.run('0.0.0.0', port, debug=True, threaded=True)


@cli.command('init-db')
@click.option('--db-url', '-d', help='PostgreSQL database URL')
@click.option('--drop', '-D', default=False, is_flag=True, help='Drop tables if they exist first')
def init_db(db_url, drop):
    if db_url is None:
        try:
            db_url = os.environ['DB_URL']
        except KeyError:
            print("Error: Please configure database via --db-url or environment variable DB_URL")
            sys.exit(1)

    with psycopg.connect(db_url, autocommit=True) as con:
        if drop:
            print("Dropping modification trigger on table mapping")
            con.execute('DROP TRIGGER IF EXISTS update_modification_timestamp ON mapping')

            print("Dropping table mappping")
            con.execute('DROP TABLE IF EXISTS mapping')

            print("Dropping function update_modification_timestamp()")
            con.execute('DROP FUNCTION IF EXISTS update_modification_timestamp()')

        print("Creating function update_modification_timestamp()")
        con.execute('''
            CREATE FUNCTION public.update_modification_timestamp() RETURNS trigger
                LANGUAGE plpgsql
                AS $$
            begin
                NEW.modified = now();
                return NEW;
            end;
            $$;
        ''')

        print("Creating table mapping")
        con.execute('''
            CREATE TABLE mapping (
                id       uuid         PRIMARY KEY DEFAULT uuid_generate_v4(),
                service  text         NOT NULL,
                shape    uuid         references shape(id) ON DELETE SET NULL,
                created  timestamptz  DEFAULT now() NOT NULL,
                modified timestamptz  DEFAULT now() NOT NULL,
                attrs    jsonb        NOT NULL DEFAULT '{}'::jsonb
            )''')

        print("Creating modification trigger on table mapping")
        con.execute('''
            CREATE TRIGGER update_modification_timestamp BEFORE UPDATE ON mapping FOR EACH ROW EXECUTE FUNCTION public.update_modification_timestamp();
        ''')


if __name__ == '__main__':
    cli()